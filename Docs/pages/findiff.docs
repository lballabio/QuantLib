
/*
 Copyright (C) 2000-2003 RiskMap srl

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software developed by the QuantLib Group; you can
 redistribute it and/or modify it under the terms of the QuantLib License;
 either version 1.0, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 QuantLib License for more details.

 You should have received a copy of the QuantLib License along with this
 program; if not, please email quantlib-dev@lists.sf.net

 The QuantLib License is also available at http://quantlib.org/license.html
 The members of the QuantLib Group are listed in the QuantLib License
*/

/*! \page findiff The finite differences framework
    This framework (corresponding to the ql/FiniteDifferences directory)
    contains basic building blocks for the numerical solution of a generic
    differential equation
    \f[
        \frac{\partial f}{\partial t} = Lf
    \f]
    where \f$ L \f$ is a differential operator in ``space'', i.e., one which
    does not contain partial derivatives in \f$ t \f$ but can otherwise
    contain any derivative in any other variable of the problem.

    Writing the equation in the above form allows us to implement
    separately the discretization of the differential operator \f$ L \f$
    and the time scheme used for the evolution of the solution. The
    QuantLib::FiniteDifferenceModel class acts as a glue
    for such two steps---which are outlined in the following sections---and
    provides the interface of the resulting finite difference model for the
    end user. Furthermore, it provides the possibility of checking and
    operating on the solution array at each step---which is typically used
    to apply an exercise condition for an option. This is also outlined in a
    section below.


    \section operators Differential operators
    The discretization of the differential operator \f$ L \f$ depends on the
    discretization chosen for the solution \f$ f \f$ of the given equation.

    Such choice is obvious in the 1-D case where the domain
    \f$ [a,b] \f$ of the equation is discretized as a series of points
    \f$ x_i, i=0 \dots N-1 \f$ (note that the index is zero based) where
    \f$ x_i = a + hi \f$ and \f$ h = (b-a)/(N-1) \f$. In turn, the solution
    \f$ f \f$ of the equation is discretized as an array
    \f$ u_i, i=0 \dots N-1 \f$ whose elements are defined as
    \f$ u_i = f(x_i) \f$.
    The discretization of the differential operator follows by substituting
    the derivatives with the corresponding incremental ratios defined in
    terms of the \f$ f_i \f$. A number of basic operators are defined in the
    framework which can be composed to form more complex operators, namely:

    the first derivative \f$ \partial/\partial x \f$ is discretized as the
    operator \f$ D_+ \f$, defined as
    \f[ D_{+} u_{i} = \frac{u_{i+1}-u_{i}}{h} \f]
    and implemented in class QuantLib::DPlus;
    the operator \f$ D_- \f$, defined as
    \f[ D_{-} u_{i} = \frac{u_{i}-u_{i-1}}{h} \f]
    and implemented in class QuantLib::DMinus;
    and the operator \f$ D_0 \f$, defined as
    \f[ D_{0} u_{i} = \frac{u_{i+1}-u_{i-1}}{2h} \f]
    and implemented in class QuantLib::DZero.
    The discretization error of the above operators is \f$ O(h) \f$ for
    \f$ D_+ \f$ and \f$ D_- \f$ and \f$ O(h^2) \f$ for \f$ D_0 \f$;

    the second derivative \f$ \partial^2/\partial x^2 \f$ is
    discretized as the operator \f$ D_+D_- \f$, defined as
    \f[ D_{+}D_{-} u_{i} = \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^2} \f]
    and implemented in class QuantLib::DPlusDMinus.
    Its discretization error is \f$ O(h^2) \f$.

    The boundary condition for the above operators is by default linear
    extrapolation. Methods are currently provided for setting other kinds
    of boundary conditions to a tridiagonal operator which these operators
    inherit, namely, Dirichlet---i.e., constant value---and Neumann---i.e.,
    constant derivative---boundary conditions.
    This might change in the future as boundary conditions could be
    astracted and passed as an additional argument to the model.

    A programmer can also implement its own operator.
    However, in order to fit into this framework it will have to implement
    a required interface depending on the chosen evolver (see below). Also,
    it is currently required to manage itself any boundary conditions. Again,
    this could change in the future.

    On the other hand, there is no obvious choice in the 2-D case.
    While it is immediate to discretize the domain into a series of points
    \f$ (x_i,y_j) \f$ and the solution into a matrix
    \f$ f_{ij} = f(x_i,y_j) \f$, there is a number of ways into which
    the \f$ f_{ij} \f$ can be arranged into an array---each of them
    determining a different discretization of the differential operators.
    One of such ways was implemented in the LexicographicalView class,
    while others will be implemented in the future. No 2-D operator is
    currently implemented.


    \section evolvers Time schemes
    Once the differential operator \f$ L \f$ has been discretized, a number
    of choices are available for discretizing the time derivative at the
    left-hand side of the equation.

    In this framework, such choice is encapsulated in so-called evolvers
    which, given \f$ L \f$ and the solution \f$ u^{(k)} \f$ at time
    \f$ t_k \f$, yield the solution \f$ u^{(k-1)} \f$ at the previous
    time step.

    A number of evolvers are currently provided in the library which
    implement well-known schemes, namely,

    the forward Euler explicit scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} = Lu^{(k)} \f]
    hence
    \f[ u^{(k-1)} = \left( I - \Delta t L \right) u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained directly;

    the backward Euler implicit scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} = Lu^{(k-1)} \f]
    hence
    \f[ \left( I + \Delta t L \right) u^{(k-1)} = u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained by solving a linear system;

    the Crank-Nicolson scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} =
        L \frac{u^{(k)}+u^{(k-1)}}{2} \f]
    hence
    \f[ \left( I + \frac{\Delta t}{2} L \right) u^{(k-1)} =
        \left( I - \frac{\Delta t}{2} L \right) u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained by solving a linear system.

    Each of the above evolvers forces a set of interface requirements upon
    the differential operator which are detailed in the documentation of the
    corresponding class, namely, QuantLib::ExplicitEuler,
    QuantLib::ImplicitEuler, and
    QuantLib::CrankNicolson, respectively.

    A programmer could implement its own evolver, which does not need to
    inherit from any base class.

    However, it must implement the following interface:

    \code
    class Evolver {
      public:
        typedef ... arrayType;
        typedef ... operatorType;
        // constructors
        Evolver(const operatorType& D);
        // member functions
        void step(arrayType& a, Time t) const;
        void setStep(Time dt);
    };
    \endcode

    Finally, we note again that the pricing of an option requires
    the finite difference model to solve the corresponding equation
    <em>backwards</em> in time. Therefore, given a discretization \f$ u \f$
    of the solution at a given time \f$ t \f$, the call
    \code
    evolver.step(u,t)
    \endcode
    must calculate the discrete solution at the <em>previous</em> time,
    \f$ t-dt \f$.


    \section conditions Step conditions
    A finite difference model can be passed a step condition to be
    applied at each step during the rollback of the solution (e.g. the early
    exercise American condition). Such condition must be embodied in a class
    derived from QuantLib::StepCondition and must implement
    the interface of the latter, namely,
    \code
    class MyCondition : public StepCondition<arrayType> {
      public:
        void applyTo(arrayType& a, Time t) const;
    };
    \endcode


    \section fdexample An example of finite difference model
    The Black-Scholes equation can be written in the above form as
    \f[ \frac{\partial f}{\partial t} =
            - \frac{\sigma^2}{2} \frac{\partial^2 f}{\partial x^2}
            - \nu \frac{\partial f}{\partial x}
            + r f. \f]
    It can be seen that the operator \f$ L_{BS} \f$ is
    \f[ L_{BS} = - \frac{\sigma^2}{2} \frac{\partial^2}{\partial x^2}
                 - \nu \frac{\partial}{\partial x}
                 + r I \f]
    and can be built from the basic operators provided in the library as
    \f[ L_{BS} = - \frac{\sigma^2}{2} D_{+}D_{-}
                 - \nu D_{0} + r I. \f]

    Its implementation closely reflects the above decomposition and
    can be written as
    \code
    class BlackScholesOperator : public TridiagonalOperator {
      public:
        BlackScholesOperator(
            double sigma, double nu,    // parameters of the
            Rate r,                     // Black-Scholes equation;
            unsigned int points,        // number of discretized points;
            double h)                   // grid spacing.
        : TridiagonalOperator(
            // build the operator by adding basic ones
            - (sigma*sigma/2.0) * DPlusDMinus(points,h)
            - nu * DZero(points,h)
            + r * TridiagonalOperator::identity(points)
        ) {}
    };
    \endcode
    taking as inputs the relevant parameters of the equation
    (\f$ \sigma \f$, \f$ \nu \f$ and \f$ r \f$) as well as model parameters
    such as the number \f$ N \f$ of grid points and their spacing \f$ h \f$.

    As simple example cases, we will use the above operator to price both an
    European and an American option. The parameters of the two options will
    be the same, namely, they will be both call options with underlying price
    \f$ u = 100 \f$, strike \f$ s = 95 \f$, residual time \f$ T = 1 \f$ year,
    dividend yield \f$ q = 3\% \f$ and volatility \f$ \sigma = 10\% \f$. The
    risk-free rate will be \f$ r = 5\% \f$. Such parameters are expressed
    using %QuantLib types as
    \code
    Option::Type type = Option::Call;
    double underlying = 100.0, strike = 95.0;
    Time residualTime = 1.0;
    Rate dividendYield = 0.03, riskFreeRate = 0.05;
    double volatility = 0.10;
    \endcode

    The grid upon which the model will act will be a logarithmic grid of
    underlying prices, i.e., \f$ f \f$ will be defined in a range
    \f$ [ \ln u_{min}, \ln u_{max}] \f$ discretized as an array
    \f$ x_i, i = 0 \dots N-1 \f$ with \f$ x_i = \ln u_{min} + ih \f$ and
    \f$ h = (\ln u_{max} - \ln u_{min})/(N-1) \f$.
    Such a grid and the corresponding vector of actual prices can be built
    as shown in the code below. The domain of the model will be defined
    as \f$ [ \ln u - \Delta, \ln u + \Delta ] \f$ where
    \f$ \Delta = 4 \sigma \sqrt{T} \f$. A number of grid points
    \f$ N = 101 \f$ will be used.
    \code
    unsigned int gridPoints = 101;
    Array grid(gridPoints), prices(gridPoints);
    double x0 = QL_LOG(underlying);
    double Delta = 4.0*volatility*QL_SQRT(residualTime);
    double xMin = x0 - Delta, xMax = x0 + Delta;
    double h = (xMax-xMin)/(gridPoints-1);
    for (unsigned int i=0; i<gridPoints; i++) {
        grid[i] = xMin + i*h;
        prices[i] = QL_EXP(grid[i]);
    }
    \endcode

    The initial condition is determined by the values of the option at
    maturity, i.e., either the difference between underlying price and
    strike if such difference is positive, or 0 if that is not the case
    (the above will have to be suitably modified for a put option or
    a straddle.)
    Such ``initial'' condition will be rolled back in time by our model.
    \code
    Array exercisingValue(gridPoints);
    for (unsigned int i=0; i<gridPoints; i++)
        exercisingValue[i] = QL_MAX(prices[i]-strike,0.0);
    \endcode

    Now the differential operator can be initialized. Also, Neumann
    initial conditions are set which correspond to the initial value
    of the derivatives at the boundaries (see the BoundaryCondition
    class documentation for details).
    \code
    double nu = riskFreeRate - dividendYield - volatility*volatility/2.0;
    TridiagonalOperator L = BlackScholesOperator(volatility, nu,
        riskFreeRate, gridPoints, h);
    L.setLowerBC(BoundaryCondition(BoundaryCondition::Neumann,
        exercisingValue[1]-exercisingValue[0]));
    L.setUpperBC(BoundaryCondition(BoundaryCondition::Neumann,
        exercisingValue[gridPoints_-1]-exercisingValue[gridPoints_-2]));
    \endcode

    We are now already set for the pricing of the European option.
    Also, the exercise condition is the only thing still to be defined
    for the American option to be priced. Such condition is equivalent to
    the statement that at each time step, the value of the option is the
    maximum between the profit realized in exercising the option (which we
    already calculated and stored in <tt>exercisingValue</tt>) and the value
    of the option should we keep it (which corresponds to the solution rolled
    back to the current time step). This logic can be implemented as:
    \code
    class ExerciseCondition : public StepCondition<Array> {
      public:
        ExerciseCondition(const Array& exercisingValue)
        : exercisingValue_(exercisingValue) {}
        void applyTo(Array& a, Time) const {
            for (unsigned int i = 0; i < a.size(); i++)
                a[i] = QL_MAX(a[i], exercisingValue_[i]);
        }
      private:
        Array exercisingValue_;
    };
    \endcode

    Everything is now ready. The model can be created gluing the piece
    together by means of the QuantLib::FiniteDifferenceModel
    class. The current value of the option is calculated by rolling back the
    solution to the current time, i.e., \f$ t = 0 \f$, and by taking the value
    corresponding at the current underlying price---which by construction
    corresponds to the central value provided that the number of grid
    points is odd.
    \code
    unsigned int timeSteps = 365;

    // build the model - Crank-Nicolson scheme chosen
    FiniteDifferenceModel<CrankNicolson<TridiagonalOperator> > model(L);

    // European option
    Array f = exercisingValue;  // initial condition
    model.rollback(f, residualTime, 0.0, timeSteps);
    double europeanValue = valueAtCenter(f);

    // American option
    f = exercisingValue;        // reset
    Handle<StepCondition<Array> > condition(
        new ExerciseCondition(exercisingValue));
    model.rollback(f, residualTime, 0.0, timeSteps, condition);
    double americanValue = valueAtCenter(f);
    \endcode
*/
